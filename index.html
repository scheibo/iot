<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>iot</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>iot</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><p><strong>iot</strong> serves as a testing 'framework' for the times when you only care
that given a certain input, a certain output is produced. <code>iot</code> tries to be
a simple solution to creating and managing test suites in this limited
environment. The basic idea behind <code>iot</code> is that it runs a given program and
saves the output (and error) streams, comparing them to the expected output
(and error). iot can handle running entire suites of such tests (i.e.
directories on input files), or simply individual tests.</p>

<p>Installing <code>iot</code> is simple - just clone the repository and copy (or link)
the 'iot' file to a location on your <code>PATH</code> (like <code>~/bin</code>, for
example). Alternatively, if you want to have it in /usr/local/bin and the
man pages installed correctly:</p>

<pre><code>$ git clone git://github.com/scheibo/iot.git
$ cd iot
$ make
$ make install
$ iot program suite
</code></pre>

<p>This web page was created by running <a href="https://github.com/rtomayko/shocco">shocco</a> against the <code>iot</code> <a href="https://github.com/scheibo/iot">source</a>
file.More information regarding <code>iot</code> can be found in the <a href="https://github.com/scheibo/iot#readme">README</a> or in
the <a href="http://scheibo.github.com/iot/iot.1.html">iot(1)</a> manpage.</p>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/bin/bash</span>

</pre></div></td></tr><tr><td class=docs>

<h2>Usage</h2>

<p>We include this line as a safety precaution -  it's important to exit
immediately if we run into any problems rather than potentially screwing
anything up.</p>

</td><td class=code><div class=highlight><pre>
<span class="nb">set</span> -e

</pre></div></td></tr><tr><td class=docs>

<p>We're going to steal an idea from <a href="https://github.com/rtomayko">rtomyako</a>'s
<a href="https://github.com/rtomayko/shocco">shocco</a> program by including the 'Usage' message as a comment and then
later doing some 'magic' to output as a help message. In order to get around
<code>shocco</code> from parsing it as documentation, we need to include some character
other than a space after the comment.</p>

</td><td class=code><div class=highlight><pre>
<span class="c">#/ Usage: iot &lt;program&gt; &lt;test-suite&gt;...</span>
<span class="c">#/        iot &lt;program&gt; &lt;test-file&gt;...</span>
<span class="c">#/        iot --command=&lt;program_runner&gt; &lt;program&gt; &lt;test-suite&gt;...</span>
<span class="c">#/</span>
<span class="c">#/ Simple test runner for input/output tests. Feeds a given program</span>
<span class="c">#/ input files and compares the output to a set of expected output files.</span>
<span class="c">#/</span>
<span class="c">#/ Configuration options:</span>
<span class="c">#/    -s, --sandboxdir=&lt;dir&gt;  change the default temp directory</span>
<span class="c">#/    -t, --testdir=&lt;dir&gt;                change default test directory</span>
<span class="c">#/    -r, --rootdir=&lt;dir&gt;                change default root directory</span>
<span class="c">#/    -c, --command=&lt;command&gt;            use &lt;command&gt; to run the program</span>
<span class="c">#/    -m, --matcher=&lt;file&gt;               use the custom matchers in &lt;file&gt;</span>
<span class="c">#/</span>
<span class="c">#/ Mode options:</span>
<span class="c">#/    -i, --immediate                    immediately print diagnositc info</span>
<span class="c">#/    -v, --verbose                      more verbose failure program msgs</span>
<span class="c">#/    -x, --sudden-death                 stop after the first failed test</span>
<span class="c">#/    -q, --quiet                        test and return exit code, no output</span>
<span class="c">#/    -u, --unified                      use a unified diff for fail output</span>
<span class="c">#/    --safe, --copy                     copy the source to allow for editting</span>

</pre></div></td></tr><tr><td class=docs>

<p>Our magic usage function, pretty much straight from <a href="https://github.com/rtomayko/shocco">shocco</a>. We parse our
own file for our comment leader and then print the stripped message.</p>

</td><td class=code><div class=highlight><pre>
usage<span class="o">()</span> <span class="o">{</span>
  grep <span class="s1">&#39;^#/&#39;</span> &lt;<span class="s2">&quot;$0&quot;</span> | cut -c4-
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>For the error function we print whatever argument we're given and the usage
block. One problem that could result from the use of <code>exit 1</code> is that
another script might misinterpret this to mean a single test failed (since
usually the fail count is the exit code). Changing status with something
like 125 might help, but that's just delaying the issue.</p>

</td><td class=code><div class=highlight><pre>
error<span class="o">()</span> <span class="o">{</span>
  <span class="nb">printf</span> <span class="s2">&quot;$(basename $0): ${*}\n\n&quot;</span> &gt;&amp;2
  usage
  <span class="nb">exit </span>1
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>Pass and Failure Messages</h2>

<p>The default pass and failure messages. We're taking after
<a href="http://rspec.info">RSpec</a> here and simply printing a very minimal
indicator. Specifying <code>-v</code> will get the user more information if they want
it. One thing to note is that the messages will get colored (red and green,
respectively) later on down the line.</p>

</td><td class=code><div class=highlight><pre>
passmsg<span class="o">()</span> <span class="o">{</span> <span class="nb">printf</span> <span class="s2">&quot;.&quot;</span>; <span class="o">}</span>
failmsg<span class="o">()</span> <span class="o">{</span> <span class="nb">printf</span> <span class="s2">&quot;F&quot;</span>; <span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>There is also the verbose options for the messages. Two things to note are
how we manually include a newline and how we're normalizing the test file
name to remove any leading path or .in cruft.</p>

</td><td class=code><div class=highlight><pre>
verbose_passmsg<span class="o">()</span> <span class="o">{</span>
  <span class="nv">test_name</span><span class="o">=</span><span class="s2">&quot;${1##/*/}&quot;</span>
  <span class="nv">test_name</span><span class="o">=</span><span class="s2">&quot;${test_name%%.in}&quot;</span>
  <span class="nb">printf</span> <span class="s2">&quot;Passed test: $test_name\n&quot;</span>
<span class="o">}</span>
verbose_failmsg<span class="o">()</span> <span class="o">{</span>
  <span class="nv">test_name</span><span class="o">=</span><span class="s2">&quot;${1##/*/}&quot;</span>
  <span class="nv">test_name</span><span class="o">=</span><span class="s2">&quot;${test_name%%.in}&quot;</span>
  <span class="nb">printf</span> <span class="s2">&quot;Failed test: $test_name\n&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>Colors</h2>

<p>In order to change the terminal colors we're going to use tput as opposed to
escape codes (for fun!). We need to be sure to finish with a <code>RESET</code> every
time we change the color or else the color will continue to be used for the
rest of the output (or at least until it is changed again).</p>

</td><td class=code><div class=highlight><pre>
<span class="nv">RED</span><span class="o">=</span><span class="k">$(</span>tput setaf 1<span class="k">)</span>
<span class="nv">GREEN</span><span class="o">=</span><span class="k">$(</span>tput setaf 2<span class="k">)</span>
<span class="nv">YELLOW</span><span class="o">=</span><span class="k">$(</span>tput setaf 3<span class="k">)</span>
<span class="nv">BOLD</span><span class="o">=</span><span class="k">$(</span>tput bold<span class="k">)</span>
<span class="nv">RESET</span><span class="o">=</span><span class="k">$(</span>tput sgr0<span class="k">)</span>

</pre></div></td></tr><tr><td class=docs>

<p>There are helper functions for printing passing, warning and failing
messages. They simply wrap their input in colors. Notice the conspicious use
of <code>printf(1)</code> in all of this code without a <code>\n</code>.</p>

</td><td class=code><div class=highlight><pre>
ppass<span class="o">()</span> <span class="o">{</span> <span class="nb">printf</span> <span class="s2">&quot;${GREEN}${*}${RESET}&quot;</span>; <span class="o">}</span>
pwarn<span class="o">()</span> <span class="o">{</span> <span class="nb">printf</span> <span class="s2">&quot;${YELLOW}${*}${RESET}&quot;</span>; <span class="o">}</span>
pfail<span class="o">()</span> <span class="o">{</span> <span class="nb">printf</span> <span class="s2">&quot;${RED}${*}${RESET}&quot;</span>; <span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>Option Processing and Setup</h2>

<p>The code for option processing is pretty self explanatory, just a loop
through the command line arguments, assigning variables and shifting as we
go. The constants determining the path begin undefined - we adjust them
later on if they haven't been set by the user. All of our booleans denote
exceptional cases, so they all start out as false unless changed by the
user.</p>

</td><td class=code><div class=highlight><pre>
<span class="nv">immediate</span><span class="o">=</span><span class="nb">false</span>
<span class="nv">verbose</span><span class="o">=</span><span class="nb">false</span>
<span class="nv">sudden_death</span><span class="o">=</span><span class="nb">false</span>
<span class="nv">quiet</span><span class="o">=</span><span class="nb">false</span>
<span class="nv">unified</span><span class="o">=</span><span class="nb">false</span>
<span class="nv">safe</span><span class="o">=</span><span class="nb">false</span>

</pre></div></td></tr><tr><td class=docs>

<p>It's sometimes difficult to remember all the proper option names, so <code>iot</code>
tries to 'do the Right Thing' if the arguments don't exactly match. Notice,
for example, that 'immeadiate' is provided as an option, as I commonly typo
this.</p>

<p>There's really two types of different parsing techniques going on here, to
deal with the <code>--option</code> and <code>--option=</code> arguments. The straightforward
options just have their argument following them, so we shift twice - once to
eliminate the option and the second time to get rid of the argument. The
<code>--option=</code> type require only one shift since the argument is included in
the name, the only difficulty here is using the special syntax for shell
variables which strips away everything that matches a regex.</p>

<p>This is kind of an ugly looking dense block, and I'm generally not a huge
fan of the arbitrary aligning of various lines, but since option parsing is
so repetitive and the code's job is so self explanatory we can save some
screen real estate here.</p>

</td><td class=code><div class=highlight><pre>
<span class="k">while </span><span class="nb">test</span> <span class="nv">$# </span>-gt 0
<span class="k">do</span>
<span class="k">  case</span> <span class="nv">$1</span> in
    -s|--sandboxdir|--tempdir<span class="o">)</span>  <span class="nv">SANDBOXDIR</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>;       <span class="nb">shift </span>2 ;;
    --tempdir<span class="o">=</span>*|--sandboxdir<span class="o">=</span>*<span class="o">)</span> <span class="nv">SANDBOXDIR</span><span class="o">=</span><span class="s2">&quot;${1##*=}&quot;</span>; <span class="nb">shift</span>   ;;

    -t|--testdir<span class="o">)</span> <span class="nv">TESTDIR</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>;                        <span class="nb">shift </span>2 ;;
    --testdir<span class="o">=</span>*<span class="o">)</span>  <span class="nv">TESTDIR</span><span class="o">=</span><span class="s2">&quot;${1##*=}&quot;</span>;                  <span class="nb">shift</span>   ;;

    -r|--root|--rootdir<span class="o">)</span>  <span class="nv">ROOTDIR</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>;                <span class="nb">shift </span>2 ;;
    --root<span class="o">=</span>*|--rootdir<span class="o">=</span>*<span class="o">)</span> <span class="nv">ROOTDIR</span><span class="o">=</span><span class="s2">&quot;${1##*=}&quot;</span>;          <span class="nb">shift</span>   ;;

    -c|--run|--command|<span class="o">)</span> <span class="nv">COMMAND</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>;                 <span class="nb">shift </span>2 ;;
    --run<span class="o">=</span>*|--command<span class="o">=</span>*<span class="o">)</span> <span class="nv">COMMAND</span><span class="o">=</span><span class="s2">&quot;${1##*=}&quot;</span>;           <span class="nb">shift</span>   ;;

    -i|--immediate|--imeadiate<span class="o">)</span> <span class="nv">immediate</span><span class="o">=</span><span class="nb">true</span>;        <span class="nb">shift</span>   ;;
    -v|-vv|--verbose<span class="o">)</span>           <span class="nv">verbose</span><span class="o">=</span><span class="nb">true</span>;          <span class="nb">shift</span>   ;;
    -q|--quiet|--silent<span class="o">)</span>        <span class="nv">quiet</span><span class="o">=</span><span class="nb">true</span>;            <span class="nb">shift</span>   ;;
    -u|--unified<span class="o">)</span>               <span class="nv">unified</span><span class="o">=</span><span class="nb">true</span>;          <span class="nb">shift</span>   ;;
    --copy|--safe|--concurrent<span class="o">)</span> <span class="nv">safe</span><span class="o">=</span><span class="nb">true</span>;             <span class="nb">shift</span>   ;;
    -x|--sudden-death|--sudden_death|--suddendeath<span class="o">)</span>
                                <span class="nv">sudden_death</span><span class="o">=</span><span class="nb">true</span>;     <span class="nb">shift</span>   ;;

    -h|--help|<span class="s1">&#39;-?&#39;</span>|<span class="s1">&#39;--?&#39;</span><span class="o">)</span> usage <span class="o">&amp;&amp;</span> <span class="nb">exit </span>0                      ;;
    -*<span class="o">)</span> error <span class="s2">&quot;unrecognized option: ${1}&quot;</span>                      ;;
    *<span class="o">)</span> <span class="nb">break</span>                                                   ;;
  <span class="k">esac</span>
<span class="k">done</span>

</pre></div></td></tr><tr><td class=docs>

<h2>Sandbox and Cleanup</h2>

<p>We need a place to send all the output from the program we're testing before
we can see if it matches the expected output. We'll need a temporary sandbox
directory to do this. We use the <code>:=</code> paramter expansion to make sure
<code>TMPDIR</code> is set. We then try to use <code>mktmp(1)</code> to create the temp directory
if we're lucky enough to have it, otherwise we create our directory far more
insecurely using the programs basename and pid. One thing to note: some
implementations of <code>mktmp(1)</code> require the string of X's and other don't, I
had trouble installing <code>shocco(1)</code> on my machines because of this issue.</p>

</td><td class=code><div class=highlight><pre>
: <span class="k">${</span><span class="nv">TMPDIR</span><span class="p">:=/tmp</span><span class="k">}</span>
: <span class="k">${</span><span class="nv">SANDBOXDIR</span><span class="p">:=</span><span class="k">$(</span>
      <span class="k">if </span><span class="nb">command</span> -v mktemp 1&gt;/dev/null 2&gt;&amp;1
      <span class="k">then</span>
<span class="k">          </span>mktemp -dt <span class="s2">&quot;$(basename $0).XXXXXXXXXXXXX&quot;</span>
      <span class="k">else</span>
<span class="k">          </span><span class="nv">dir</span><span class="o">=</span><span class="s2">&quot;$TMPDIR/$(basename $0).$$&quot;</span>
          mkdir <span class="s2">&quot;$dir&quot;</span>
          <span class="nb">echo</span> <span class="s2">&quot;$dir&quot;</span>
      <span class="k">fi</span>
  <span class="k">)}</span>

</pre></div></td></tr><tr><td class=docs>

<p>Here we perform a bit of a sanity check to make sure we're not using a
stupid location for our temp directory which would result in lots of
potentially nasty things happening.</p>

</td><td class=code><div class=highlight><pre>
<span class="k">if</span> <span class="o">[</span> -z <span class="s2">&quot;$SANDBOX&quot;</span> -o <span class="s2">&quot;$WORK&quot;</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span> <span class="o">]</span>; <span class="k">then</span>
<span class="k">  </span>error <span class="s2">&quot;could not create a temporary sandbox directory&quot;</span>
<span class="k">fi</span>

</pre></div></td></tr><tr><td class=docs>

<p>Most importantly we're going to register an <code>EXIT</code> trap to clean up our temp # directory unless we're killed witbh <code>SIGKILL.</code></p>

<p>All of the code dealing with creating and cleaning up our temporary sandbox # directory comes at you straight out of <a href="https://github.com/rtomayko/shocco">shocco</a>.</p>

</td><td class=code><div class=highlight><pre>
<span class="nb">trap</span> <span class="s2">&quot;rm -rf $SANDBOXDIR&quot;</span> 0

</pre></div></td></tr><tr><td class=docs>

<h2>'Root' Directory</h2>

<p>Here we try to determine where the root directory of the project we're
testing is. We first need to check if if <code>ROOTDIR</code> was already set by the
user through the <code>--rootdir</code> command line option. This leverages the
<code>${var:+val}</code> variable subsititution form which returns its value if
<code>ROOTDIR</code> is defined and not null.We start by defaulting to the current
directory - in the most basic case <code>iot</code> will be run from the top level
directory. However, in order to provide more of a convenience for people
using source control, we'll also check if we're in a <code>hg</code> or <code>git</code>
repository, using the root of that repository as the root directory for the
script. This allows us to call the script anywhere in the project and it
will still be able to find the correct files.</p>

</td><td class=code><div class=highlight><pre>
<span class="k">if</span> <span class="o">[</span> <span class="k">${</span><span class="nv">ROOTDIR</span><span class="p">:+1</span><span class="k">}</span> -eq 1 <span class="o">]</span>; <span class="k">then</span>
<span class="k">  </span><span class="nv">ROOTDIR</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>
  hg root 1&gt;/dev/null 2&gt;&amp;1 <span class="o">&amp;&amp;</span> <span class="nv">ROOTDIR</span><span class="o">=</span><span class="sb">`</span>hg root<span class="sb">`</span>
  git rev-parse --show-toplevel 1&gt;/dev/null 2&gt;&amp;1 <span class="o">&amp;&amp;</span> <span class="nv">ROOTDIR</span><span class="o">=</span><span class="sb">`</span>git rev-parse --show-toplevel<span class="sb">`</span>
<span class="k">fi</span>

</pre></div></td></tr><tr><td class=docs>

<h2>Final Preparations</h2>

<p>Last tiny bit of argument parsing. The first argument to iot is the test
file and the rest of the options denote suites or tests to run to run.</p>

<p>The safe option copies the entire source code of the program and is thus
likely to be slow, but its the only way to safely be able to concurrently
edit the program while we're testing it. Using <code>rsync(1)</code> here might be a
better idea if we're trying to do some autotesting-like behavior.</p>

</td><td class=code><div class=highlight><pre>
<span class="o">[[</span> -f <span class="s2">&quot;${ROOTDIR}/${1}&quot;</span> <span class="o">]]</span> <span class="o">||</span> error <span class="s2">&quot;expects program to test as argument&quot;</span>

<span class="k">if</span> <span class="nv">$safe</span>; <span class="k">then</span>
<span class="k">  </span>cp <span class="s2">&quot;${ROOTDIR}/${1}&quot;</span> <span class="s2">&quot;${SANDBOXDIR}/program&quot;</span>
  <span class="nv">PROGNAME</span><span class="o">=</span><span class="s2">&quot;${SANDBOXDIR}/program&quot;</span>
<span class="k">else</span>
<span class="k">  </span><span class="nv">PROGNAME</span><span class="o">=</span><span class="s2">&quot;${ROOTDIR}/${1}&quot;</span>
<span class="k">fi</span>

</pre></div></td></tr><tr><td class=docs>

<p>We a place to concatenate our error messages that build up, so we create a
<code>results</code> file to append to. In order to avoid collisions with test names
we'll stick on our pid as well. We're also going to create an <code>immediate</code>
results file as well, which will kind of act like a buffer to <code>results</code>.</p>

</td><td class=code><div class=highlight><pre>
<span class="nv">results</span><span class="o">=</span><span class="s2">&quot;${SANDBOXDIR}/iot-results-$$&quot;</span>
<span class="nv">immediate_results</span><span class="o">=</span><span class="s2">&quot;${SANDBOXDIR}/iot-immediate-$$&quot;</span>

</pre></div></td></tr><tr><td class=docs>

<h2>Testing Function</h2>

<p>Here lies the heart of the code. The control flow is broken up into several
subroutines that all share the same variables (I guess that's one benefit of
the shell's unscoped variables?). This seperation of the code into logical
units is purely for convenience and presentation.</p>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs>

<p>The first step in testing a given program is to determine where it's
expected out and error files would be located. <code>testfile</code>, <code>suite</code> and
<code>location</code> are all passed to <code>dotest</code> (the main testing function) and
<code>get_locations</code> utilizes these arguments to figure out where the expect
files are. If the <code>location</code> passed to <code>dotest</code> is "top" then we just check
in the top level of the suite, otherwise we delve into the subdirectories.
<em>Note:</em> these expect files may not exist - we're just trying to find out
where they would be <em>if</em> they did exist.</p>

</td><td class=code><div class=highlight><pre>
get_locations<span class="o">()</span> <span class="o">{</span>
  <span class="nv">testname</span><span class="o">=</span><span class="s2">&quot;$(basename $testfile)&quot;</span>
  <span class="nv">testname</span><span class="o">=</span><span class="s2">&quot;${testname%%.in}&quot;</span>

  <span class="k">if</span> <span class="s2">&quot;$location&quot;</span> <span class="o">=</span> <span class="s2">&quot;top&quot;</span>; <span class="k">then</span>
<span class="k">    </span><span class="nv">expect_out</span><span class="o">=</span><span class="s2">&quot;${suite}/${testname}.out&quot;</span>
    <span class="nv">expect_err</span><span class="o">=</span><span class="s2">&quot;${suite}/${testname}.err&quot;</span>
  <span class="k">else</span> <span class="c"># &quot;in&quot;</span>
    <span class="nv">expect_out</span><span class="o">=</span><span class="s2">&quot;${suite}/out/${testname}&quot;</span>
    <span class="nv">expect_err</span><span class="o">=</span><span class="s2">&quot;${suite}/err/${testname}&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>The next step is to actually run the program with the test as input, saving
the output streams in our <code>SANDBOXDIR</code>. <code>eval</code> shows it's ugly face here,
but if the <code>COMMAND</code> that was passed in contains addition options (like
<code>valgrind --leak-check=yes</code>, or something of that sort) then <code>eval</code> is
necessary.</p>

</td><td class=code><div class=highlight><pre>
run_test<span class="o">()</span> <span class="o">{</span>
  <span class="nv">actual_out</span><span class="o">=</span><span class="s2">&quot;${SANDBOXDIR}/${testname}.out&quot;</span>
  <span class="nv">actual_err</span><span class="o">=</span><span class="s2">&quot;${SANDBOXDIR}/${testname}.err&quot;</span>

  <span class="k">if</span> <span class="o">[</span> <span class="k">${</span><span class="nv">COMMAND</span><span class="p">:+1</span><span class="k">}</span> -eq 1 <span class="o">]</span>; <span class="k">then</span>
<span class="k">    </span><span class="nb">eval</span> <span class="k">${</span><span class="nv">COMMAND</span><span class="k">}</span> <span class="nv">$PROGNAME</span> &lt; <span class="nv">$testfile</span> &gt; <span class="nv">$actual_out</span> 2&gt; <span class="nv">$actual_err</span>
  <span class="k">elif</span> <span class="o">[</span> -x <span class="nv">$PROGNAME</span> <span class="o">]</span>; <span class="k">then</span>
    <span class="s2">&quot;./$PROGNAME&quot;</span>  &lt; <span class="nv">$testfile</span> &gt; <span class="nv">$actual_out</span> 2&gt; <span class="nv">$actual_err</span>
  <span class="k">else</span>
<span class="k">    </span>error <span class="s2">&quot;$PROGNAME is not executable, cannot run tests&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>Now we need to actually perform the <code>diff</code>. Since we need to possibly
compare both out and error streams we need to make a 'combined' file that
holds both of these appended to each other, provided the expect files exist.
If neither a test or output file is provided we're going to throw an error
since it is likely a mistake by the user and not intentional (if the user
expects no output or errors he should provide empty err and out files to
make his intentions clear). <code>dotest</code> will check the exit status of this
which in turn will be the exit value of the <code>diff</code>.</p>

</td><td class=code><div class=highlight><pre>
perform_diff<span class="o">()</span> <span class="o">{</span>
  <span class="nv">combined_expect</span><span class="o">=</span><span class="s2">&quot;${SANDBOXDIR}/${testname}.combined.expect&quot;</span>
  <span class="nv">combined_result</span><span class="o">=</span><span class="s2">&quot;${SANDBOXDIR}/${testname}.combined.result&quot;</span>

  <span class="k">if</span> <span class="o">[</span> -f <span class="s2">&quot;$expect_out&quot;</span> <span class="o">]</span>; <span class="k">then</span>
<span class="k">    </span>cat <span class="nv">$expect_out</span> &gt;&gt; <span class="nv">$combined_expect</span>
    cat <span class="nv">$actual_out</span> &gt;&gt; <span class="nv">$function</span>
    <span class="nv">out</span><span class="o">=</span><span class="nb">true</span>
<span class="nb">  </span><span class="k">fi</span>

<span class="k">  if</span> <span class="o">[</span> -f <span class="s2">&quot;$expect_err&quot;</span> <span class="o">]</span>; <span class="k">then</span>
<span class="k">    </span>cat <span class="nv">$expect_err</span> &gt;&gt; <span class="nv">$combined_expect</span>
    cat <span class="nv">$actual_err</span> &gt;&gt; <span class="nv">$combined_result</span>
    <span class="nv">err</span><span class="o">=</span><span class="nb">true</span>
<span class="nb">  </span><span class="k">fi</span>

<span class="k">  if</span> ! <span class="nv">$out</span> <span class="o">&amp;&amp;</span> ! <span class="nv">$err</span>; <span class="k">then</span>
<span class="k">    </span>error <span class="s2">&quot;no expected output files for $testname&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>diff <span class="nv">$combined_expect</span> <span class="nv">$combined_result</span> &gt;/dev/null 2&gt;&amp;1
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>Very straightforward chunk of code for the passing and failing message s- we
simply print a different message depending on whether or not we've been
passed the option <code>--verbose</code> or not.</p>

</td><td class=code><div class=highlight><pre>
passing_message<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="nv">$verbose</span>; <span class="k">then</span>
<span class="k">    </span>ppass <span class="sb">`</span>verbose_passmsg <span class="nv">$testfile</span> <span class="nv">$count</span><span class="sb">`</span>
  <span class="k">else</span>
<span class="k">    </span>ppass <span class="sb">`</span>passmsg <span class="nv">$testfile</span> <span class="nv">$count</span><span class="sb">`</span>
  <span class="k">fi</span>
<span class="o">}</span>

failing_message<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="nv">$verbose</span>; <span class="k">then</span>
<span class="k">     </span>ppass <span class="sb">`</span>verbose_failmsg <span class="nv">$testfile</span> <span class="nv">$count</span><span class="sb">`</span>
   <span class="k">else</span>
<span class="k">     </span>ppass <span class="sb">`</span>failmsg <span class="nv">$testfile</span> <span class="nv">$count</span><span class="sb">`</span>
   <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>Abstracted from the next function, <code>failing_case</code>, this function expects an
<code>out_file</code> and a <code>err_file</code> and decides what format to print them in. It
relies on <code>out</code> and <code>err</code> which were set in <code>perform_diff</code> and simply save
having to test <code>[ -f &lt;file&gt; ]</code> multiple times. If we get just an <code>out_file</code>,
we dont print the 'stdout:' line since it is implied. However, one we get an
error stream in the mix we need to distinguish between the 2.</p>

</td><td class=code><div class=highlight><pre>
failing_output<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="nv">$out</span> <span class="o">&amp;&amp;</span> ! <span class="nv">$err</span>; <span class="k">then</span>
<span class="k">    </span>cat <span class="nv">$out_file</span> &gt;&gt; <span class="nv">$immediate</span>
  <span class="k">elif</span> ! <span class="nv">$out</span> <span class="o">&amp;&amp;</span> <span class="nv">$err</span>; <span class="k">then</span>
<span class="k">    </span>pwarn <span class="s2">&quot;stderr:\n&quot;</span> &gt;&gt; <span class="nv">$immediate</span>
    cat <span class="nv">$err_file</span> &gt;&gt; <span class="nv">$immediate</span>
  <span class="k">else</span>
<span class="k">    </span>pwarn <span class="s2">&quot;stdout:\n&quot;</span> &gt;&gt; <span class="nv">$immediate</span>
    cat <span class="nv">$out_file</span> &gt;&gt; <span class="nv">$immediate</span>
    pwarn <span class="s2">&quot;stderr:\n&quot;</span> &gt;&gt; <span class="nv">$immediate</span>
    cat <span class="nv">$err_file</span> &gt;&gt; <span class="nv">$immediate</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>Most of the interesting stuff this function does was extrcacted to
<code>failing_output</code>, but it's worth noting we are outputing everything to
<code>immediate</code> until the end, where we then append it to the real <code>results</code>
file. Also note we're adding in some spaces to indent our output.</p>

</td><td class=code><div class=highlight><pre>
failing_case<span class="o">()</span> <span class="o">{</span>
  failing_message

  pfail <span class="s2">&quot;\n${failcount}) ${suite}/${testname}\n&quot;</span> &gt;&gt; <span class="nv">$immediate</span>

  pwarn <span class="s2">&quot;${BOLD}Expected:\n&quot;</span> &gt;&gt; <span class="nv">$immediate</span>
  failing_output <span class="nv">$expect_out</span> <span class="nv">$expect_err</span>

  pwarn <span class="s2">&quot;${BOLD}Received:\n&quot;</span> &gt;&gt; <span class="nv">$immediate</span>
  failing_output <span class="nv">$actual_out</span> <span class="nv">$actual_err</span>

  sed <span class="s1">&#39;s/^/    /g&#39;</span> <span class="nv">$immediate</span> &gt;&gt; <span class="nv">$immediate</span>
  cat <span class="nv">$immediate</span> &gt;&gt; <span class="nv">$results</span>

  <span class="k">if</span> <span class="nv">$immediate</span> <span class="k">then</span>;
    cat <span class="nv">$immediate</span>
  <span class="k">elif</span> <span class="nv">$suddendeath</span>; <span class="k">then</span>
<span class="k">    </span>cat <span class="nv">$results</span> <span class="o">&amp;&amp;</span> <span class="nb">exit </span>1
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>Here's the function that is composed of all the above subroutines. We're
passed <code>testfile</code>, <code>suite</code> and <code>location</code> and then we call the respective
subs to do all the work. We make sure we check the <code>quiet</code> flag so that we
don't output anything if the flag is set.</p>

</td><td class=code><div class=highlight><pre>
dotest<span class="o">()</span> <span class="o">{</span>
  <span class="nv">testfile</span><span class="o">=</span><span class="nv">$1</span>; <span class="nv">suite</span><span class="o">=</span><span class="nv">$2</span>; <span class="nv">location</span><span class="o">=</span><span class="nv">$3</span>

  get_locations
  run_test
  perform_diff

  <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> -eq 0 <span class="o">]</span>; <span class="k">then</span>
<span class="k">    if</span> ! <span class="nv">$quiet</span>; <span class="k">then</span>
<span class="k">      </span>passing_message
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span><span class="nv">failcount</span><span class="o">=</span><span class="sb">`</span>expr <span class="nv">$failcount</span> + 1<span class="sb">`</span>
    <span class="k">if</span> ! <span class="nv">$quiet</span>; <span class="k">then</span>
<span class="k">      </span>failing_case
    <span class="k">fi</span>
<span class="k">  fi</span>

<span class="k">  </span><span class="nv">testcount</span><span class="o">=</span><span class="sb">`</span>expr <span class="nv">$testcount</span> + 1<span class="sb">`</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>Main Testing Loop</h2>

<p>The default location we're going to be look for tests when resolving
'pseudo' paths and suite names. The <code>:=</code> form is used here again, it's
similar to the <code>||=</code> in Ruby.</p>

</td><td class=code><div class=highlight><pre>
<span class="nv">default</span><span class="o">=</span><span class="s2">&quot;${ROOTDIR}/tests&quot;</span>
: <span class="k">${</span><span class="nv">TESTDIR</span><span class="p">:=default</span><span class="k">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>We keep track of two counter variables in our test loop - <code>testcount</code> and
<code>failcount</code>. <code>testcount</code> keeps track of the number of tests run and
<code>failcount</code> keeps track of the number of tests which have failed. These are
mainly useful for the summary message at the end, but we also use failcount
as our exit code.</p>

</td><td class=code><div class=highlight><pre>
<span class="nv">testcount</span><span class="o">=</span>0
<span class="nv">failcount</span><span class="o">=</span>0

</pre></div></td></tr><tr><td class=docs>

<p>If we're in quiet mode we just care about the exit code and don't need the
chatty 'Started' message</p>

</td><td class=code><div class=highlight><pre>
<span class="k">if</span> ! <span class="nv">$quiet</span>; <span class="k">then </span><span class="nb">echo</span> <span class="s2">&quot;Started&quot;</span>; <span class="k">fi</span>

</pre></div></td></tr><tr><td class=docs>

<p>We're going to loop through everything left standing on the command line and
try to figure out what type of argument we have (pseudo path or entire test
suite), ultimately passing each test file to <code>dotest</code> with either a 'top' or
an 'in' argument signalling to <code>dotest</code> where it should look for expected
output files.</p>

<p>The first case (in order of increasing complication) is the case where we
we're given a suite - in that case we're given a directory name and we just
run the <code>dotest</code> function on each test file in that directory.</p>

<p>The final case is the pseudo path - something of the form 'suite/path'. This
kind of gets ugly. First we test of the suite directory even exists - we can
leverage (abuse?) <code>dirname</code> to strip the suite name. We then check both
styles for how test files can be defined, this time making use of <code>basename</code>
to strip the other half of the pseudopath. We then have to impose an
ordering on the potential test files found (ick! - TODO: better way?) before
passing it off to <code>dotest</code></p>

</td><td class=code><div class=highlight><pre>
<span class="k">for </span>arg in <span class="nv">$@</span>; <span class="k">do</span>

<span class="k">  if</span> <span class="o">[</span> -d <span class="s2">&quot;${TESTDIR}/$arg&quot;</span> <span class="o">]</span>; <span class="k">then</span>

<span class="k">    for </span>file in <span class="k">$(</span>find <span class="k">${</span><span class="nv">TESTDIR</span><span class="k">}</span> -type f -path <span class="s2">&quot;${TESTDIR}/$arg/*.in&quot;</span><span class="k">)</span>; <span class="k">do</span>
<span class="k">      </span>dotest file <span class="s2">&quot;${TESTDIR}/$arg&quot;</span> <span class="s2">&quot;top&quot;</span>
    <span class="k">done</span>

<span class="k">    for </span>file in <span class="k">$(</span>find <span class="k">${</span><span class="nv">TESTDIR</span><span class="k">}</span> -type f -path <span class="s2">&quot;${TESTDIR}/$arg/in/*&quot;</span><span class="k">)</span>; <span class="k">do</span>
<span class="k">      </span>dotest file <span class="s2">&quot;${TESTDIR}/$arg&quot;</span> <span class="s2">&quot;in&quot;</span>
    <span class="k">done</span>

<span class="k">  elif</span> <span class="o">[</span> -d <span class="s2">&quot;${TESTDIR}/$(dirname $arg)&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span>
       <span class="o">[</span> -f <span class="s2">&quot;${TESTDIR}/$(dirname $arg)/$(basename $arg).in&quot;</span> <span class="o">]</span> <span class="o">||</span>
       <span class="o">[</span> -f <span class="s2">&quot;${TESTDIR}/$(dirname $arg)/in/$(basename $arg)&quot;</span> <span class="o">]</span>; <span class="k">then</span>

<span class="k">       </span><span class="nv">suite</span><span class="o">=</span><span class="s2">&quot;${TESTDIR}/$(dirname $arg)&quot;</span>
       <span class="k">if</span> <span class="o">[</span> -f <span class="s2">&quot;$suite/$(basename $arg).in&quot;</span> <span class="o">]</span>; <span class="k">then</span>
<span class="k">         </span>dotest <span class="s2">&quot;$suite/$(basename $arg).in&quot;</span> suite <span class="s2">&quot;top&quot;</span>
       <span class="k">else</span>
<span class="k">         </span>dotest <span class="s2">&quot;$suite/in/$(basename $arg)&quot;</span> suite <span class="s2">&quot;in&quot;</span>
       <span class="k">fi</span>

<span class="k">  else</span>

<span class="k">    </span>error <span class="s2">&quot;can&#39;t figure out what to do with $arg&quot;</span>

  <span class="k">fi</span>

<span class="k">done</span>

</pre></div></td></tr><tr><td class=docs>

<h2>Wrapping Up</h2>

<p>Standard case finishing action (i.e. we didn't terminate early thanks to
<code>--immediate</code> or <code>--sudden-death</code>) - we simply display the results and the
statistics (passes vs. failures). We don't display the results when
immediate is set since they've already all been shown. The results are
already conveniently indented from when they were created.</p>

</td><td class=code><div class=highlight><pre>
<span class="k">if</span> ! <span class="nv">$quiet</span>; <span class="k">then</span>
<span class="k">  </span><span class="nb">echo</span> <span class="s2">&quot;Finished&quot;</span>

  <span class="k">if</span> ! <span class="nv">$immediate</span>; <span class="k">then</span>
<span class="k">    </span>cat <span class="nv">$results</span>
  <span class="k">fi</span>

<span class="k">  if</span> <span class="o">[</span> <span class="nv">$failcount</span> -eq 0 <span class="o">]</span>; <span class="k">then</span>
<span class="k">      </span>ppass <span class="s2">&quot;\n\n${testcount} tests, ${failcount} failures\n&quot;</span>
  <span class="k">else</span>
<span class="k">      </span>pfail <span class="s2">&quot;\n\n${testcount} tests, ${failcount} failures\n&quot;</span>
  <span class="k">fi</span>
<span class="k">fi</span>

<span class="nb">exit</span> <span class="nv">$failcount</span>

</pre></div></td></tr><tr><td class=docs>

<h2>Copyright</h2>

<p>Copyright (C) <a href="http://scheibo.com/about">Kirk Scheibelhut</a><br />
This is Free Software distributed under the MIT license.</p>

</td><td class=code><div class=highlight><pre>
:


</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
